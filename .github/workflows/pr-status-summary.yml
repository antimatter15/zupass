name: PR Issue Summary with Last Responder

on:
  issue_comment:
    types: [created, edited, deleted]

jobs:
  update-issue-summary:
    runs-on: ubuntu-latest
    if: github.event.issue.pull_request
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: "16"

      - name: Install dependencies
        run: npm install @actions/github @actions/core

      - name: Update issue summary
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          const github = require('@actions/github');
          const core = require('@actions/core');

          function parseIssue(commentBody) {
            const match = commentBody.match(/ISSUE:\s*(.+)$/im);
            return match ? match[1].trim() : null;
          }

          function parseExistingSummary(summary) {
            const issues = {};
            const lines = summary.split('\n');
            for (const line of lines) {
              const match = line.match(/- \[([ x])\] (.*?) \(Last: (.*?), Turn: (.*?)\)/);
              if (match) {
                const [, checked, issue, lastResponder, turn] = match;
                issues[issue] = { checked: checked === 'x', lastResponder, turn };
              }
            }
            return issues;
          }

          function getLastResponder(issue, comments) {
            const issueComments = comments.filter(c => parseIssue(c.body) === issue);
            return issueComments.length > 0 ? issueComments[issueComments.length - 1].user.login : null;
          }

          function generateSummary(comments, existingIssues, prCreator) {
            const newIssues = {};
            comments.forEach(comment => {
              const issue = parseIssue(comment.body);
              if (issue) {
                newIssues[issue] = { lastResponder: comment.user.login };
              }
            });

            const allIssues = new Set([...Object.keys(existingIssues), ...Object.keys(newIssues)]);

            let summary = "## Issue Summary\n\n";
            for (const issue of Array.from(allIssues).sort()) {
              let checked, lastResponder, turn;
              if (issue in existingIssues) {
                checked = existingIssues[issue].checked;
                lastResponder = getLastResponder(issue, comments) || existingIssues[issue].lastResponder;
              } else {
                checked = false;
                lastResponder = newIssues[issue].lastResponder;
              }
              turn = lastResponder === prCreator ? "Reviewer" : "Proposer";
              const checkbox = checked ? "[x]" : "[ ]";
              summary += `- ${checkbox} ${issue} (Last: ${lastResponder}, Turn: ${turn})\n`;
            }
            return summary;
          }

          async function run() {
            try {
              const octokit = github.getOctokit(process.env.GITHUB_TOKEN);
              const context = github.context;
              const { owner, repo } = context.repo;
              const prNumber = context.payload.issue.number;

              const { data: pullRequest } = await octokit.rest.pulls.get({
                owner,
                repo,
                pull_number: prNumber,
              });

              const { data: comments } = await octokit.rest.issues.listComments({
                owner,
                repo,
                issue_number: prNumber,
              });

              const prCreator = pullRequest.user.login;

              let summaryComment = null;
              let existingIssues = {};
              for (const comment of comments) {
                if (comment.body.startsWith("## Issue Summary")) {
                  summaryComment = comment;
                  existingIssues = parseExistingSummary(comment.body);
                  break;
                }
              }

              const summary = generateSummary(comments, existingIssues, prCreator);

              if (summaryComment) {
                await octokit.rest.issues.updateComment({
                  owner,
                  repo,
                  comment_id: summaryComment.id,
                  body: summary,
                });
              } else {
                await octokit.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: prNumber,
                  body: summary,
                });
              }

              console.log("Issue summary updated successfully.");
            } catch (error) {
              core.setFailed(error.message);
            }
          }

          run();
